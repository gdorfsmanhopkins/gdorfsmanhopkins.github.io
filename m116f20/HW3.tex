\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2020}

\begin{document}
\begin{center}
\Large {Homework 3}\\
\small {Due Thursday, September 24}
\end{center}
\section*{Implementation Part}
This week we finally get to implement a cryptosystem.  Recall that this is a collection $(\cM,\cC,\cK,d,e)$ where $\cM$ is the space of message text, $\cC$ is the space of cipher text, $\cK$ is the space of keys, $e:\cM\times\cK\to\cC$ is the encryption function and $d:\cC\times\cK\to\cM$ is the decryption function.  Our message space will be often something like $\cM = \bZ/N\bZ$, that is, it is a collection of numbers.  But we want to send messages that consist of text, letters, punctuation, the like.  In order to do this we must develop a dictionary between strings and integers called an \textit{encoding scheme}.  We will use the ASCII encoding scheme.
\begin{enumerate}
  \item{
  We start with a warmup.  This part won't be graded, but may be useful for those without much programming experience.  Parts (a) and (b) are useful tricks for string manipulation, and (c) and (d) introduce the functions which do the ASCII translation.
  \begin{enumerate}
    \item{
    Python/Sage reads strings like lists.  Try running the following code to see what I mean:
    \begin{verbatim}
x = "Hello World!"
for i in x:
    print(i)
    \end{verbatim}
    }
    \item{
    You can use the \verb|+| operation to add characters to a string.  Run the following code to see what I mean:
    \begin{verbatim}
x = "Hello"
y = x + '!'
print(y)
    \end{verbatim}
    }
    \item{
    ASCII is a dictionary between characters and bytes.  Recall that a \textit{byte} of data is 8 \textit{bits}, that is 8 digits in binary, or equivalently, a number $n$ such that $0\le n<2^8$.  In particular, each character corresponds to a unique integer $0,1,...,255$.  In python, you can turn a character into its corresponding integer using the function \verb|ord|.  Try this out a bit by running the following lines of code:
    \begin{enumerate}
      \item{\verb|ord('a')|}
      \item{\verb|ord('A')|}
      \item{\verb|ord(' ')|}
      \item{\verb|ord(',')|}
      \item{\verb|ord(a)| (what happened here?)}
      \item{\verb|ord("hello")| (what happened here?)}
    \end{enumerate}
    }
    \item{
    \verb|ord| has an inverse, which takes as input a byte (that is, a number $0,1,...,255$) and returns a character.  In python this is \verb|chr|.  Try it out:
    \begin{enumerate}
      \item{\verb|chr(98)|}
      \item{\verb|chr(40)|}
      \item{\verb|chr(ord('F'))|}
      \item{\verb|ord(chr(201))|}
    \end{enumerate}
    }
  \end{enumerate}
}
\item{
Now we build our translation functions.  The idea is simple enough: via \verb|ord| a string is just a sequence collection of bytes, which we can think of as a number in base 256.  Therefore translating an string to an integer and back should can be thought of as computing the number from this base 256 representation:
\begin{enumerate}
  \item{
    Build a function \verb|textToInt(w)| whose input is a string \verb|w|: a list of characters $c_0c_1c_2c_3...c_r$ and whose output is an integer $n$ satisfying:
    \[n = \sum_{i=0}^r ord(c_i)*256^i.\]
  }
\end{enumerate}
The inverse then consists of finding the base 256 expansion n, and then converting each `digit' (which is a byte, i.e., a number 0,...,255) into its corresponding letter using \verb|chr|:
\begin{enumerate}
  \setcounter{enumii}{1}
  \item{
    Build an inverse to the function from part (a).  Call it \verb|intToText(n)|, it should take as input a positive integer $n$ and return a string.  \textbf{Hint}: If you are stuck try the following two steps:
    \begin{enumerate}[(1)]
      \item{
      Compute the base 256 expansion $[B_0,B_1,...,B_r]$ of $n$.  This means each $B_i$ is an integer between 0 and 255, and
      \[n = B_0 + B_1*256 + B_2*256^2 + \cdots + B_r*256^r.\]
      You should be able to do this with minor modifications to your \verb|getBinary| code from Homework 2.
      }
      \item{
      Return the string $c_0c_1c_2...c_r$ where $c_i = chr(B_i)$.
      }
    \end{enumerate}
    Once you have done these two steps, streamline it so that you dont have to remember the list $[B_0,...,B_r]$ which can in practice be quite large.  This should follow a similar principle to computing the binary in each step of the loop of \verb|fastPowerSmall| from Homework 2.
    }
    \item{
    Test it out on the follwing:
    \begin{enumerate}
      \item{\verb|textToInt("Hello World!")|}
      \item{Run \verb|intToText| on your output from (i).}
      \item{Run \verb|intToText| on 157690076402712651527241.  Did it work?}
    \end{enumerate}
    }
  \end{enumerate}
  }
  \item{
  Now let's implement a symmetric encryption system.  Fix a prime number $p$ and let $\cM = \cC = \cK = \bF_p^*$.  The encryption function and decryption functions are
  \begin{eqnarray*}
    e(m,k)\equiv km\mod p&\text{    and    }&d(c,k)\equiv k^{-1}c\mod p.
  \end{eqnarray*}
  \begin{enumerate}
    \item{
    Implement \verb|encrypt(m,k)| and \verb|decrypt(c,k)|.  (Encrypt will be very simple, decrypt will need to compute $k^{-1}$, but you can use a function from a previous homework to do this quickly!).
    }
    \item{
     Let $p = 370141817103067776979133$, and choose the key $k=147955927473629958316$.  Decrypt the following cipher $c=85449848686775252245536$ and use \verb|intToText| to read the message!
    }
    \item{
    Use the same prime $p$ from above and choose your own key.  Encrypt and decrypt $m=$\verb|textToInt("Hello!")| with this key.  Then apply \verb|intToText|.  You should recover your original message!
    }
    \item{
    Do the same thing as in (c) above for $p=23169331$.  What went wrong?
    }
  \end{enumerate}
  }
  \item{For each of the following collections of input data compute the Diffie-Hellman shared secret from both Alice and Bob's perspective
  \begin{enumerate}
    \item{
    Prime number $p = 17$.  Primitive root $g=3$.  Alice's secret $a=5$, Bob's secret $b = 11$.
    }
    \item{
    $p = 56509$.  $g=2$. $a = 3482$, $b=20487$.
    }
    \item{
    $p = 370141817103067776979133,g=31415926535$\\
    $a = 112233445566778899,b=998877665544332211$
    }
  \end{enumerate}
  }
\end{enumerate}
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{4}
  \item{
  Let's prove some properties of the discrete logarithm.
  \begin{enumerate}
    \item{
    Let $g$ be a primitive root of $\bF_p^*$.  Fix $a,b\in\bZ$ and suppose that $g^a\equiv g^b\mod p$.  Show that $a\equiv b\mod(p-1)$.
    }
    \item{
    Use part (a) to prove that the discrete log map $\log_g:\bF_p^*\longrightarrow\bZ/(p-1)\bZ$ is well defined.
    }
    \item{
    Show that the map $\log_g$ from part (b) is \textit{bijective}.  (Hint, can you construct an explicit inverse?).
    }
    \item{
    Show that $\log_g(ab) = log_g(a)+\log_g(b)$ for all $a,b\in\bF_p^*$.  (For those of you have seen group theory, this means $\log_g$ is a homomorphism, and in light of (c) an \textit{isomorphism}!)
    }
  \end{enumerate}
  }
  \item{
  Let $p$ be an odd prime and $g$ a primitive root of $\bF_p^*$.  Prove that $a\in\bF_p^*$ has a square root if and only if $\log_g(a)$ is even.
  }
  \item{
  In Homework 2 we studied square roots mod $p$.  Let's use this to study square roots modulo $p^e$ for some positive exponent $e$.  Let $p$ be a prime not equal to 2, and let $b$ be an integer not divisible by $p$.  Suppose further that $b$ has a square root modulo $p$, i.e., the congruence:
  \[x^2\equiv b\mod p,\]
  has a solution.
  \begin{enumerate}
    \item{
    Show that for every exponent $e\ge 1$, $b$ has a square root module $p^e$.  That is, the congruence
    \[x^2\equiv b\mod p^e\]
    has a solution.  (\textbf{Hint:} Use induction on $e$, finding a solution modulo $p^{e+1}$ by modifying the solution modulo $p^e$.)
    }
    \item{
    Let $x=\alpha$ be a square root of $b$ modulo $p$.  Prove that in part (a) we can find a square root root $\beta$ of $b$ mod $p^e$ such that $\alpha\equiv\beta\mod p$.
    }
    \item{
    Suppose $\beta,\beta'$ are two square roots of $b$ mod $p^e$, and further that they are both equivalent to $\alpha\mod p$ as in part (b).  Show that $\beta\equiv\beta'\mod p^e$.
    }
    \item{
    Conclude that the congruence $x^2\equiv b\mod p^e$ has either 2 solutions or 0 solutions.  (Use HW2 Probem 8).
    }
  \end{enumerate}
  }
  Recall in class we proved that the Discrete Logarithm Problem (DLP) is harder than the Diffie-Hellman Problem (DHP).  Explicitely, we showed that if you have a solution to the DLP you can use this to solve the DHP.  We finish this assignment with a proof of this sort, following [HPS Exercise 2.7].  We first must introduce the following problem:
  \begin{definition}
    The \textit{decision Diffie-Hellman Problem} (dDHP) is a s follows.  Suppose that you are given 3 number $A,B,$ and $C$, and suppose $A$ and $B$ are equal to
    \begin{eqnarray*}
      A\equiv g^a\mod p&\text{and}&B\equiv g^b\mod p,
    \end{eqnarray*}
    for some (unknown) $a$ and $b$.  Determine whether $C\equiv g^{ab}\mod p$.
  \end{definition}
  This is the first of several of \textit{decision} variants of problems we will see.  Notice the DHP asks you to compute $g^{ab}$ where as the dDHP just asks you to check if a given set of data is the solution.
  \item{
  \begin{enumerate}
    \item{
    Show that the DHP is harder than the dDHP.  That is, show a solution to the DHP gives a solution to the dDHP.
    }
    \item{
    Do you think the dDHP is hard or easy? Why?
    }
  \end{enumerate}
  }
\end{enumerate}
\end{document}
