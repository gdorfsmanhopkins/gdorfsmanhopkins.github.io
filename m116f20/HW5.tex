\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2020}

\begin{document}
\begin{center}
\Large {Homework 5}\\
\small {Due Thursday, October 8}
\end{center}
\section*{Implementation Part}
\begin{enumerate}
  \item{
  Implement Sun Tzu's algorithm for solving concurrent congruences (i.e., the Chinese Remainder Theorem).  Specifically, define a function \verb|CRT(moduli,residues)| which satisfies the following:
  \begin{center}
    \begin{tabular}{c|c}
      Input & Output\\
      \hline
      A list of moduli $m_1,\cdots,m_t$ (positive integers) & If moduli are pairwise coprime\\
      A list of integers $a_1,\cdots,a_t$ &$x$ satisfying $x\equiv a_i\mod m_i$ for all $i$.\\
      &Otherwise an error message.
    \end{tabular}
  \end{center}
  \textit{Hints}:
  \begin{itemize}
    \item{One way you could do this is to make an auxiliary function \verb|CRTPairs(m1,m2,a1,a2)| which solves the problem for 2 congruences, and have \verb|CRT| feed recursively into \verb|CRTPairs|}
    \item{
    Naively checking the moduli are coprime takes running the Euclidean algorithm $\cO(t^2)$ times, but you should be able to do so only running it $\cO(t)$ times.
    }
  \end{itemize}
  }
  \item{
  Implement the baby steps-giant steps algorithm to solve the DLP for $\bF_p^*$.  In particular, define a function \verb|babyGiant(g,h,p,N=p-1)| satisfying the following:
  \begin{center}
    \begin{tabular}{c|c}
      Input & Output\\
      \hline
      A prime $p$ & $\log_g(h)$ if it exists\\
      An element $g\in\bF_p^*$ & \\
      An element $h\in\bF_p^*$ & \\
      The order $N$ of $g$.
    \end{tabular}
  \end{center}
  If no order $N$ is given your algorithm should set $N=p-1$.\\
  \textit{Hint}
  \begin{itemize}
    \item{
    Recall that the hardest part of this algorithm wasn't making the lists of baby steps and giant steps, but of searching for and finding an element that is in both lists.  If you do this by just comparing each element of the list one by one, then this will take $\cO(\sqrt N^2) = \cO(N)$ steps, and you won't have saved any time at all over the brute force attack of the discrete log.  Instead, we will implement a \textit{hash  table}.  In python this type of data structure is a \textit{set}.  You could initiate this like \verb|babysteps = set()|, and then add an element $x$ using \verb|babysteps.add(x)|.  The great thing about sets is you can do something like \verb|x in babysteps| which will return true if $x$ is in the set and false otherwise, and since $x$ is paired with an index it can do this in $\cO(1)$ time!  The downside is hash tables aren't ordered, so you need some other way remember the discrete logs of your elements.  One way is to also have a babysteps list alongside the set, and each time you generate a giant step, see if it is in the set (using \verb|x in babystep| which is $\cO(1)$), if it is then run through the babystep list to see which position the match is.  This is better because you are only running through the babysteps list once (rather than $\sqrt N$ times with the naive list comparison).
    }
  \end{itemize}
  }
  \item{
  Implement to Pohlig-Hellman algorithm to solve the DLP for an element $g\in\bF_p^*$ of order $N = m_1m_2...m_t$ (for coprime $m_i$).  Specifically, define a function \verb|pohligHellman(g,h,p,factors)|
  \begin{center}
    \begin{tabular}{c|c}
      Input & Output\\
      \hline
      A prime $p$ & $\log_g(h)$ if it exists\\
      An element $g\in\bF_p^*$ & \\
      An element $h\in\bF_p^*$ & \\
      The prime power factors $m_1,\cdots m_t$ of $|g|$ & \
    \end{tabular}
  \end{center}
  \textit{Hints}
  \begin{itemize}
    \item{
    The structure should loosely be as follows.  Reduce the problem to solving the DLP for elements of smaller order, let \verb|babyGiant| solve those problems (make sure to tell it the order is smaller, otherwise you aren't saving any time), and then use \verb|CRT| to stitch them together.
    }
    \item{
    It is difficult in general to compute $|g|$ (about as difficult as factoring $p-1$), and so checking if the $m_i$ are indeed the prime factors of $|g|$ may be difficult.  Instead, check that $g^{m_1m_2...m_t} = 1$.  In this case your algorithm should still work (see Problem 6).
    }
  \end{itemize}
  }
  \item{
  Use \verb|CRT| to solve to following sets of congruences, and check that the solution given works.
  \begin{enumerate}
    \item{
      $x \equiv 9\mod 23$ and $x = 25\mod 41$
    }
    \item{
    \begin{eqnarray*}
      x&\equiv& 1\mod2\\
      x&\equiv& 2\mod3\\
      x&\equiv& 4\mod5\\
      x&\equiv& 6\mod7\\
      x&\equiv& 10\mod 11\\
      x&\equiv& 1\mod 13\\
      x&\equiv& 16\mod 17
    \end{eqnarray*}
    }
  \end{enumerate}
  }
  \item{
  Let's test out your log functions!
  \begin{enumerate}
    \item{
    Let $p = 113$.  Use baby steps-giant steps to compute $\log_3 19$ modulo $p$.
    }
    \item{
    Notice that $112$ factors as $2^4*7$.  Use this information and Pohlig-Hellman to compute $\log_3 19$ and see if your answer matches.
    }
    \item{
    Let $p = 30235367134636331149$.  Try using baby steps-giant steps to compute the discrete log $\log_6 3295$ modulo $p$.
    }
    \item{
    You might have had trouble getting the last one to run.  I did.  What if I told you that $p-1$ has the following prime factorization?
    \[p-1 = 2^2 * 3^2 * 13 * 41143 * 335341 * 4682597.\]
    Now use Pohlig-Hellman to speed up your computation.  (It speeds it up considerably!).  Use fast powering to make sure you got the right answer (it is very satisfying!).
    }
  \end{enumerate}
  }
\end{enumerate}
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{5}
  \item{
  In defining \verb|babyGiant| and \verb|pohligHellman| we didn't always know the exact order of $g$, and couldn't necessarily check it directly.  Therefore the exact proofs of correctness of these algorithms in class need to be modified to make sure our algorithms work.  Let's do this here.
  \begin{enumerate}
    \item{
    If \verb|babyGiant| doesn't receive an order as an input it defaults to $|g| = p-1$.  Explain why this is just assuming that $g$ is a primitive root.  Suppose $g$ is not a primitive root but \verb|babyGiant| still assumes $N=p-1$.  Prove that \verb|babyGiant| returns the correct logarithm.
    }
    \item{
    More generally, suppose you specify a $N$ as a positive multiple of $|g|$ in \verb|babyGiant|.  Prove that it returns the correct logarithm.
    }
    \item{
    For \verb|pohligHellman| instead of checking that the $m_i$ were indeed the prime power factors of $|g|$, we just checked that $g^{m_1m_2\cdots m_t} = 1$.  Prove that if this condition holds (and the $m_i$ are still coprime) that \verb|pohligHellman| returns the correct logarithm.
    }
    \item{
    Even if the order given as input is not entirely correct (but say a multiple of the actual order), these algorithms work.  Still, there are drawbacks to not having the correct order.  What are they?  (e.g., if using $p-1$ in \verb|babyGiant| always works, why don't we just always set $N=p-1$?).
    }
  \end{enumerate}
  }
  \item{
  \begin{enumerate}
    \item{
    Show that \verb|CRT| runs in $\cO(\log N)$ steps where $N = m_1m_2\cdots m_t$ is the product of the moduli.  (You may assume your basic operations $+,-,\times,\div$ are all $\cO(1)$).
    }
    \item{
    Baby steps-giant steps as we introduced in class took $\cO(\sqrt N\log N)$ because of how long it took to find an element in both the baby steps list and the giant steps list.  In question 2 we implemented a hash table instead of a list, and checking if an element is in a hash table takes $\cO(1)$ steps (which doesn't depend on the size of the table!).  Use this fact to prove that your implementation runs in $\cO(\sqrt N)$ steps instead.
    }
  \end{enumerate}
  }
  \item{
  Let's prove the uniqueness part of the Chinese Remainder theorem.
  \begin{enumerate}
    \item{
    Let $a,b,c$ be positive integers and suppose that:
    \begin{eqnarray*}
      a|c,&b|c,&\gcd(a,b) = 1.
    \end{eqnarray*}
    Then $ab|c$.
    }
    \item{
    Suppose $m_1,\cdots,m_t$ are pairwise coprime positive integers, and suppose $a_1,\cdots,a_t\in\bZ$.  Show that if $y$ and $z$ are both solutions to the system of congruences
    \begin{eqnarray*}
      x&\equiv& a_1\mod m_1\\
      x&\equiv& a_2\mod m_2\\
      &\vdots&\\
      x&\equiv& a_t\mod m_t,
    \end{eqnarray*}
     then $y\equiv z\mod m_1m_2\dots m_t$
     }
   \end{enumerate}
  }
\end{enumerate}
  Let's finish by proving the following theorem:
\begin{theorem}\label{SquareRoots}
  Let $m$ be an odd number and $a$ an integer not divisble by any of the prime factors of $m$.  Then $a$ has a square root mod $m$ if and only if $a^{\frac{p-1}{2}}\equiv 1\mod p$ for every prime factor $p$ of $m$.
\end{theorem}
\begin{enumerate}
  \setcounter{enumi}{8}
  \item{
  \begin{enumerate}
    \item{
    Let $a$ be an integer not divisble by an odd prime $p$.  Show that $a$ has a square root mod $p$ if and only if $a^{\frac{p-1}{2}}\equiv 1\mod p$. (\textit{Hint:} Use HW2 Problem 8.)
    }
    \item{
    Let $m = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_t^{\alpha_t}$ and $a$ an integer.  Show that $a$ has a square root mod $m$ if and only if it has a square root mod $p_i^{\alpha_i}$ for each $i$. (\textit{Hint:} Use the Chinese Remainder Theorem.)
    }
    \item{
    Let $m$ be an odd number and suppose $a$ is an integer not divisible by any prime factor of $m$.  Show $a$ has a square root mod $m$ if and only if it has a square root mod $p$ for every prime $p$ dividing $m$. (\textit{Hint:} Use HW3 Problem 7).
    }
    \item{
    Deduce Theorem \ref{SquareRoots} from parts (a),(b), and (c) above.
    }
    \item{
    Can you relax any of the hypotheses of Theorem \ref{SquareRoots}?  For example, what if $m$ is even?  Or what if some prime factor of $m$ divides $a$?  Compute some examples and informally discuss your thoughts.
    }
  \end{enumerate}
  }
\end{enumerate}
\end{document}
