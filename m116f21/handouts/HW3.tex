\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2021}

\begin{document}
\begin{center}
\Large {Homework 3}\\
\small {Due Thursday, September 23}
\end{center}
\section*{Implementation Part}
This week we finally get to implement a cryptosystem.  Recall that this is a collection $(\cM,\cC,\cK,d,e)$ where $\cM$ is the space of message text, $\cC$ is the space of cipher text, $\cK$ is the space of keys, $e:\cM\times\cK\to\cC$ is the encryption function and $d:\cC\times\cK\to\cM$ is the decryption function.  Our message space will be often something like $\cM = \bZ/N\bZ$, that is, it is a collection of numbers.  But we want to send messages that consist of text, letters, punctuation, the like.  In order to do this we must develop a dictionary between strings and integers called an \textit{encoding scheme}.  We will use the ASCII encoding scheme.
\begin{enumerate}
  \item{
  We start with a warmup.  This part won't be graded, but may be useful for those without much programming experience.  Parts (a) and (b) are useful tricks for string manipulation, and (c) and (d) introduce the functions which do the ASCII translation.
  \begin{enumerate}
    \item{
    Python/Sage reads strings like lists.  Try running the following code to see what I mean:
    \begin{verbatim}
x = "Hello World!"
for i in x:
    print(i)
    \end{verbatim}
    }
    \item{
    You can use the \verb|+| operation to add characters to a string.  Run the following code to see what I mean:
    \begin{verbatim}
x = "Hello"
y = x + '!'
print(y)
    \end{verbatim}
    }
    \item{
    ASCII is a dictionary between characters and bytes.  Recall that a \textit{byte} of data is 8 \textit{bits}, that is 8 digits in binary, or equivalently, a number $n$ such that $0\le n<2^8$.  In particular, each character corresponds to a unique integer $0,1,...,255$.  In python, you can turn a character into its corresponding integer using the function \verb|ord|.  Try this out a bit by running the following lines of code:
    \begin{enumerate}
      \item{\verb|ord('a')|}
      \item{\verb|ord('A')|}
      \item{\verb|ord(' ')|}
      \item{\verb|ord(',')|}
      \item{\verb|ord(a)| (what happened here?)}
      \item{\verb|ord("hello")| (what happened here?)}
    \end{enumerate}
    }
    \item{
    \verb|ord| has an inverse, which takes as input a byte (that is, a number $0,1,...,255$) and returns a character.  In python this is \verb|chr|.  Try it out:
    \begin{enumerate}
      \item{\verb|chr(98)|}
      \item{\verb|chr(40)|}
      \item{\verb|chr(ord('F'))|}
      \item{\verb|ord(chr(201))|}
    \end{enumerate}
    }
  \end{enumerate}
}
\item{
Now we build our translation functions.  The idea is simple enough: via \verb|ord| a string is just a sequence collection of bytes, which we can think of as a number in base 256.  Therefore translating an string to an integer and back should can be thought of as computing the number from this base 256 representation:
\begin{enumerate}
  \item{
    Build a function \verb|textToInt(w)| whose input is a string \verb|w|: a list of characters $c_0c_1c_2c_3...c_r$ and whose output is an integer $n$ satisfying:
    \[n = \sum_{i=0}^r ord(c_i)*256^i.\]
  }
\end{enumerate}
The inverse then consists of finding the base 256 expansion n, and then converting each `digit' (which is a byte, i.e., a number 0,...,255) into its corresponding letter using \verb|chr|:
\begin{enumerate}
  \setcounter{enumii}{1}
  \item{
    Build an inverse to the function from part (a).  Call it \verb|intToText(n)|, it should take as input a positive integer $n$ and return a string.  \textbf{Hint}: If you are stuck try the following two steps:
    \begin{enumerate}[(1)]
      \item{
      Compute the base 256 expansion $[B_0,B_1,...,B_r]$ of $n$.  This means each $B_i$ is an integer between 0 and 255, and
      \[n = B_0 + B_1*256 + B_2*256^2 + \cdots + B_r*256^r.\]
      You should be able to do this with minor modifications to your \verb|getBinary| code from Homework 2.
      }
      \item{
      Return the string $c_0c_1c_2...c_r$ where $c_i = chr(B_i)$.
      }
    \end{enumerate}
    Once you have done these two steps, streamline it so that you dont have to remember the list $[B_0,...,B_r]$ which can in practice be quite large.  This should follow a similar principle to computing the binary in each step of the loop of \verb|fastPowerSmall| from Homework 2.
    }
    \item{
    Test it out on the follwing:
    \begin{enumerate}
      \item{\verb|textToInt("Hello World!")|}
      \item{Run \verb|intToText| on your output from (i).}
      \item{Run \verb|intToText| on 157690076402712651527241.  Did it work?}
    \end{enumerate}
    }
  \end{enumerate}
  }
  \item{
  Now let's implement a symmetric encryption system.  Fix a prime number $p$ and let $\cM = \cC = \cK = \bF_p^*$.  The encryption function and decryption functions are
  \begin{eqnarray*}
    e(m,k)\equiv km\mod p&\text{    and    }&d(c,k)\equiv k^{-1}c\mod p.
  \end{eqnarray*}
  \begin{enumerate}
    \item{
    Implement \verb|encrypt(m,k)| and \verb|decrypt(c,k)|.  (Encrypt will be very simple, decrypt will need to compute $k^{-1}$, but you can use a function from a previous homework to do this quickly!).
    }
    \item{
     Let $p = 370141817103067776979133$, and choose the key $k=147955927473629958316$.  Decrypt the following cipher $c=85449848686775252245536$ and use \verb|intToText| to read the message!
    }
    \item{
    Use the same prime $p$ from above and choose your own key.  Encrypt and decrypt $m=$\verb|textToInt("Hello!")| with this key.  Then apply \verb|intToText|.  You should recover your original message!
    }
    \item{
    Do the same thing as in (c) above for $p=23169331$.  What went wrong?
    }
  \end{enumerate}
  }
  \item{For each of the following collections of input data compute the Diffie-Hellman shared secret from both Alice and Bob's perspective
  \begin{enumerate}
    \item{
    Prime number $p = 17$.  Primitive root $g=3$.  Alice's secret $a=5$, Bob's secret $b = 11$.
    }
    \item{
    $p = 56509$.  $g=2$. $a = 3482$, $b=20487$.
    }
    \item{
    $p = 370141817103067776979133,g=31415926535$\\
    $a = 112233445566778899,b=998877665544332211$
    }
  \end{enumerate}
  }
  \item{
  Now implement the Elgamal cryptosystem (we introduced this at the end of class on 9/16, and it summarized in the book [HPS Section 2.4], or in the notes I posted on the discord ``elgamal" channel).  Fix a prime $p$ and an element $g\in\bF_p^*$ and save them as global variables.
  \begin{enumerate}
    \item{
    Write Alice's algorithms: \verb|generatePublicKey(a)| which takes as input Alice's private key and returns their public key; and \verb|elgamalDecrypt(c1,c2,a)| which takes as input ciphertext $(c_1,c_2)$ as well as Alice's private key and returns a message.
    }
    \item{
    Write Bob's algorithm: \verb|elgamalEncrypt(m,A)| which takes as input Alice's public key $A$ and a message $m$ and returns ciphertext $(c_1,c_2)$.  (Recall that Bob needs to choose a random exponent to encrypt with.  \verb|ZZ.random_element(lowerBound,upperBound)| should come in handy).
    }
    \item{
    Test it out.  Let $p=9787$ and $g=34$.  Pick any exponent you like and generate a public key as Alice.  Then put on your Bob hat and encrypt a message (secret number).  Finally decrypt it as alice and make sure you got what you started with.  Do this for various values of $a$ and messages.
    }
    \item{
    I'm trying to send you a message.  Let
    \begin{eqnarray*}
      p&=&753022235974397591242683563886842009117\\
      g&=&47393028462819284673.
    \end{eqnarray*}
    Suppose further that your secret key is $a=314159265358979323846$.  I send you the following ciphertext:
    \begin{eqnarray*}(c_1,c_2) =& (449164960684688587557185888310931655332,\\
      &608713686463403616105013668689979824341).
    \end{eqnarray*}
    Decode my message. (Use \verb|intToText| to read it!)
    }
    \item{
    You're welcome to respond to my message.  With the same prime and generator, I have a public key of
    \[A = 418194837551245918495968754919547251501.\]
    Encode me a message, and post it on the discord ``elgamal" channel.  It should still be well enough encrypted so that only I can read it!
    }
  \end{enumerate}
  }
\end{enumerate}
\newpage
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{5}
  \item{
  Let's prove some properties of the discrete logarithm.
  \begin{enumerate}
    \item{
    Let $g$ be a primitive root of $\bF_p^*$.  Fix $a,b\in\bZ$ and suppose that $g^a\equiv g^b\mod p$.  Show that $a\equiv b\mod(p-1)$.
    }
    \item{
    Use part (a) to prove that the discrete log map $\log_g:\bF_p^*\longrightarrow\bZ/(p-1)\bZ$ is well defined.
    }
    \item{
    Show that the map $\log_g$ from part (b) is \textit{bijective}.  (Hint, can you construct an explicit inverse?).
    }
    \item{
    Show that $\log_g(ab) = log_g(a)+\log_g(b)$ for all $a,b\in\bF_p^*$.  (For those of you have seen group theory, this means $\log_g$ is a homomorphism, and in light of (c) an \textit{isomorphism}!)
    }
    \item{
    Let $p$ be an odd prime and $g$ a primitive root of $\bF_p^*$.  Prove that $a\in\bF_p^*$ has a square root if and only if $\log_g(a)$ is even.
    }
    \item{
    (BONUS:) We've talked about how the Discrete Log Problem is rather secure.  That is, given an odd prime $p$, a primitive root $g\in\bF_p^*$, and some $x = g^a\mod p$, it should be hard to find $a$.  Nevertheless, it is easy to tell whether $a$ is even or odd.  Describe a fast algorithm to do so and prove it's correct.  (This is often referred to as saying the \textit{least significant bit} of the discrete log problem is insecure).
    }
  \end{enumerate}
}
\end{enumerate}
\end{document}
