\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2020}

\begin{document}
\begin{center}
\Large {Homework 4}\\
\small {Due Thursday, September 30}
\end{center}
\section*{Implementation Part}
\begin{enumerate}
  \item{
  Implement the na\"ive algorithm to solve the discrete log problem.  In particular, define a function \verb|naiveDLP(g,h,p)| satisfying the following:
  \begin{center}
    \begin{tabular}{c|c}
      Input & Output\\
      \hline
      A prime $p$ & $\log_g(h)$ if it exists\\
      An element $g\in\bF_p^*$ & \\
      An element $h\in\bF_p^*$ & \\
    \end{tabular}
  \end{center}
 It should work by computing $g\mod p,g^2\mod p,g^3\mod p,\cdots$ in a loop until it finds $h$, then returning the relevant power.
  }
  \item{
  Implement the baby steps-giant steps algorithm to solve the DLP for $\bF_p^*$.  In particular, define a function \verb|babyGiant(g,h,p,N=p-1)| satisfying the following:
  \begin{center}
    \begin{tabular}{c|c}
      Input & Output\\
      \hline
      A prime $p$ & $\log_g(h)$ if it exists\\
      An element $g\in\bF_p^*$ & \\
      An element $h\in\bF_p^*$ & \\
      The order $N$ of $g$.
    \end{tabular}
  \end{center}
  If no order $N$ is given your algorithm should set $N=p-1$.\\
  \textit{Hint}
  \begin{itemize}
    \item{
    Recall that the hardest part of this algorithm wasn't making the lists of baby steps and giant steps, but of searching for and finding an element that is in both lists.  If you do this by just comparing each element of the list one by one, then this will take $\cO(\sqrt N^2) = \cO(N)$ steps, and you won't have saved any time at all over the brute force attack of the discrete log.  Instead, we will implement a \textit{hash  table}.  In python this type of data structure is a \textit{set}.  You could initiate this like \verb|babysteps = set()|, and then add an element $x$ using \verb|babysteps.add(x)|.  The great thing about sets is you can do something like \verb|x in babysteps| which will return true if $x$ is in the set and false otherwise, and since $x$ is paired with an index it can do this in $\cO(1)$ time!  The downside is hash tables aren't ordered, so you need some other way remember the discrete logs of your elements.  One way is to also have a babysteps list alongside the set, and each time you generate a giant step, see if it is in the set (using \verb|x in babystep| which is $\cO(1)$), if it is then run through the babystep list to see which position the match is.  This is better because you are only running through the babysteps list once (rather than $\sqrt N$ times with the naive list comparison).
    }
  \end{itemize}
  }
  \item{
  Let's do some testing!
  \begin{enumerate}
    \item{
    Let $p = 113$.  Use the \verb|naiveDLP| and \verb|babyGiant| to compute $\log_3 19$ modulo $p$.
    }
    \item{
    Let $p = 1073741827$.  Use \verb|naiveDLP| and \verb|babyGiant| to compute $\log_2 54382$.  (Note: I got both of them to run, but one was instant and the other took nearly four minutes!  This should demonstrate that although \verb|babyGiant| is exponential, it is still a significant improvement over the na\"ive algorithm)).
    }
    \item{
    Let $p = 30235367134636331149$.  Try using \verb|babyGiant| to compute the discrete log $\log_6 3295$ modulo $p$.  Did it run?
    }
  \end{enumerate}
  }
\end{enumerate}
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{3}
  \item{
  In defining \verb|babyGiant| didn't always know the exact order of $g$, and couldn't necessarily check it directly.  Therefore the exact proofs of correctness of these algorithms in class need to be modified to make sure our algorithms work.  Let's do this here.
  \begin{enumerate}
    \item{
    If \verb|babyGiant| doesn't receive an order as an input it defaults to $|g| = p-1$.  Explain why this is just assuming that $g$ is a primitive root.  Suppose $g$ is not a primitive root but \verb|babyGiant| still assumes $N=p-1$.  Prove that \verb|babyGiant| returns the correct logarithm.
    }
    \item{
    Even if the order given as input is not entirely correct (but say a multiple of the actual order), the algorithms work.  Still, there are drawbacks to not having the correct order.  What are they?  (e.g., if using $p-1$ in \verb|babyGiant| always works, why don't we just always set $N=p-1$?).
    }
    \item{
    Baby steps-giant steps as we introduced in class took $\cO(\sqrt N\log N)$ because of how long it took to find an element in both the baby steps list and the giant steps list.  In question 2 we implemented a hash table instead of a list, and checking if an element is in a hash table takes $\cO(1)$ steps (which doesn't depend on the size of the table!).  Use this fact to prove that your implementation runs in $\cO(\sqrt N)$ steps instead.
    }
  \end{enumerate}
  }
\end{enumerate}
In class we showed that an Elgamal oracle can solve the Diffie-Hellman problem.  Let's show the other direction, and conclude that Elgamal and Diffie-Hellman are equally difficult.
\begin{enumerate}
  \setcounter{enumi}{4}
  \item{
  Suppose you have access to an oracle who can solve the Diffie-Hellman problem.  That is, for any prime $p$, given $g^a$ and $g^b\mod p$, the oracle can tell you $g^{ab}\mod p$.  Show that you can use this oracle to crack the Elgamal Public Key Cryptosystem.  Precisely, suppose Alice publishes a prime $p$, an element $g\in\bF_p^*$, and a public key $A$, and Bob sends the cipher text $(c_1,c_2)$.  Consult with the oracle to find the message Bob sent.
  }
\end{enumerate}
Problem 2.10 in [HPS] gives an example of a cryptosystem where Alice and Bob need to send two rounds of messages back and forth to communicate.  We reproduce it here.  It might be fun to follow along on cocalc!
\begin{enumerate}
  \setcounter{enumi}{5}
  \item{
  Alice and Bob decide on a prime $p = 32611$.  The rest is secret.  But any information crossing the middle channel (via the arrows) should be assumed to be intercepted by Eve.\\
  \begin{tabular}{l|c||c||c}
    &Alice &Eve& Bob\\
    \hline\hline
    1.&Alice has message $m = 11111$&&\\
    \hline
    2.&Alice chooses random $a = 3589$&&\\
    \hline
    3.&Alice computes $u = m^a\mod p = 15950$ & $\longrightarrow$ &Bob recieves $u$\\
    \hline
    4.&&&Bob chooses random $b = 4037$.\\
    \hline
    5.&Alice recieves $v$ & $\longleftarrow$ & Bob Computes $v = u^b\mod p = 15422$\\
    \hline
    6.&Alice knows $a' = 15619$&&\\
    \hline
    7.&Alice computes $w=v^{a'}\mod p = 27257$&$\longrightarrow$&Bob recieves $w$.\\
    \hline
    8.&&&Bb knows $b' = 31883$\\
    \hline
    9.&&&Bob computes $w^{b'}\mod p = 11111$.\\
    &&&That's $m$!
  \end{tabular}
  \begin{enumerate}
    \item{
    Notice how Alice knows a second exponent $a'=15619$ in step 6.  Where does this number come from and how does this relate to $a=3589$ from step 2?  Similarly how do Bob's exponents $b=4037$ and $b'=31883$ relate? Use this information to explain how the algorithm works.
    }
    \item{
    Formulate a general version of this algorithm using variables and show that it works in general.
    }
    \item{
    Can a solution to the DLP break this cryptosystem?  Justify your answer.
    }
    \item{
    Can a solution to the DHP break this cryptosystem?  Justify your answer.
    }
  \end{enumerate}
  }
  \item{
  In Homework 2 we studied square roots mod $p$.  Let's use this to study square roots modulo $p^e$ for some positive exponent $e$.  Let $p$ be a prime not equal to 2, and let $b$ be an integer not divisible by $p$.  Suppose further that $b$ has a square root modulo $p$, i.e., the congruence:
  \[x^2\equiv b\mod p,\]
  has a solution.
  \begin{enumerate}
    \item{The following fact may be handy.  Show that $(a+b)^p = a^p + b^p + pab($stuff$)$.  Conclude that  $(a+b)^p = a^p+b^p\mod p$.  (This is often called the \textit{freshman's dream} by cynical math professors who have seen a similar formula on too many calculus exams).
    }
    \item{
    Show that for every exponent $e\ge 1$, $b$ has a square root module $p^e$.  That is, the congruence
    \[x^2\equiv b\mod p^e\]
    has a solution.  (\textbf{Hint:} Use induction on $e$, finding a solution modulo $p^{e+1}$ by modifying the solution modulo $p^e$.)
    }
    \item{
    Let $x=\alpha$ be a square root of $b$ modulo $p$.  Prove that in part (a) we can find a square root root $\beta$ of $b$ mod $p^e$ such that $\alpha\equiv\beta\mod p$.
    }
    \item{
    Suppose $\beta,\beta'$ are two square roots of $b$ mod $p^e$, and further that they are both equivalent to $\alpha\mod p$ as in part (b).  Show that $\beta\equiv\beta'\mod p^e$.
    }
    \item{
    Conclude that the congruence $x^2\equiv b\mod p^e$ has either 2 solutions or 0 solutions.  (Use HW2 Probem 8).
    }
  \end{enumerate}
  }
  \item{
  Let $G$ and $H$ be groups, and denote their multiplication rules by $*_G$ and $*_H$ respectively.  A function $\varphi:G\to H$ is called a \textit{homomorphism} if for all $a,b\in G$:
  \[\varphi(a*_G b) = \varphi(a)*_H\varphi(g).\]
  \begin{enumerate}
    \item{
    Recall that the identiy of a group $e\in G$ is an element such that for every $g\in G$ ,$e*g=g*e=1$.  Show that the identity element of a group $G$ is unique.
    }
    \item{
    Let $e_G$ be the identity of $G$ and $e_H$ the identity of $H$.  Show that if $\varphi$ is a homomorphism then $\varphi(e_G) = e_H$
    }
    \item{
    Let $g\in G$.  Recall that an inverse to $g$ is an element $g^{-1}$ such that $g*g^{-1} = g^{-1}*g=1$.  Show that $g^{-1}$ is unique.
    }
    \item{
    Show that $\varphi(g^{-1})=\varphi(g)^{-1}$ for all $g\in G$.
    }
    \item{
    Suppose $\varphi:G\to H$ is a homomorphism and is bijective.  Show that the inverse $\varphi^{-1}:H\to G$ is a homomorphism as well.  Such a map is called an \textit{isomorphism}.  We then call $G$ and $H$ \textit{isomorphic}.  This is a notion of being the \textit{same} group in some sense.
    }
    \item{
    Prove that $\bF_p^*$ and $\bZ/(p-1)\bZ$ are isomorphic.  (You are welcome to cite work already done in past homeworks).
    }
  \end{enumerate}
  }
\end{enumerate}
\end{document}
