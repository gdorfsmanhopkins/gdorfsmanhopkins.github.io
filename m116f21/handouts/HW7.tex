\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{seqsplit}
\usepackage{ulem}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2021}

\begin{document}
\begin{center}
\Large {Homework 7}\\
\small {Due \textbf{Saturday}, October 30}
\end{center}
\section*{Implementation Part}
Let's implement the factorization using difference of squares!  We'll first do the quadratic sieve:
\begin{enumerate}
  \item{Build a function \verb|quadraticSieve(a,b,B,N)| which returns the $B$-smooth numbers of the form $t^2-N$ for integers $t$ satisfying $a\le t< b$, as well as their prime factorizations.  Do this by implementing the quadratic sieve discussed in the Thursday 10/21 lecture, or in 3.7.2 in [HPS].  It will likely be useful to follow along the example for tha chapter, which should correspond to \verb|quadraticSieve(15,30,7,221)|.  The steps of the algorithm should loosely be as follows.
  \begin{enumerate}[(I)]
    \item{Make a list $a^2-N, (a+1)^2-N, (a+2)^2-N,\cdots,(b-1)^2-N$.  You will sieve this list.}
    \item{I found it easier to take care of the even prime powers first.  Divide all the even numbers in your list by 2 as many times as possible.  \textit{Keep track of how many powers of 2 you factored out}}
    \item{For each odd prime $p<B$, solve $x^2\equiv N\mod p$.  If there is no solution, move on.  If there is one solutiion...well, then you've factored $N$! (Why?) Otherwise:
    \begin{enumerate}
      \item{There are 2 solutions $\alpha_p$ and $\beta_p = p-\alpha_p$.  Find the smallest $t>a$ such that $t\equiv\alpha_p\mod p$.  Starting at the element of your list corresponding to $t^2-N$, divide every $p$'th element of your list by $p$ (keeping track of how many factors of $p$ you're pulling out!).  Do the same for $\beta_p$}
      \item{For the corresponding prime powers $p^e$ such that $p^e<2(b-a)$, solve $x^2\equiv N\mod p^e$, $\alpha_{p^e}$ and $\beta_{p^e}$.  Find the smallest $t>a$ such that $t\equiv\alpha_{p^e}\mod p$.  Starting at the element of your list corresponding to $t^2-N$, divide every $p^e$'th element of your list by $p$ (keeping track of the factors again!).  Do the same for $\beta_{p^e}$.}
    \end{enumerate}
    }
    \item{Look through your list.  Everything that's been reduced to 1 is $B$-smooth!  Return the corresponding $t$ values as well as the prime factorizations of $t^2-N$}
  \end{enumerate}
  A few remarks.
  \begin{itemize}
    \item{You are free to use Sage's function \verb|prime_range(lower,Upper)|, which returns a list of primes between the lower and upper bounds.}
    \item{Finding square roots mod $p$ is easy, but we haven't discussed it yet in generality.  Therefore you are free to use Sage's function \verb|Mod(a,p).sqrt()| which returns a square root of $a$ mod $p$.  This will technically return an element of $\bF_p$ so you may want to cast it as an \verb|int| before continuing.  It turns out that if $p\equiv 3\mod 4$ there is a really slick 1 step algorithm to find a square root (see question 5).}
    \item{The above is how I implemented it, but you can be creative if you can think of improvements.  As for the way you store your data, again your use of data structures is your choice, but I kept track of a list of lists, which had one entry for each integer $t$ between $a$ and $b$.  Then the entry in the list corresponding to $t$ was
    \[[d,\#\text{Powers of }2,\#\text{Powers of }3,\cdots,\#\text{Powers of }p],\]
    where $p$ is the largers prime $<B$, and $d$ is what remains after dividing $t^2-N$ by primes during the sieving.   Then I'm just adding to the appropriate powers at each step, and at the end I'm looking for entries where $d=1$, and the prime factorization is right there!
    }
  \end{itemize}
  }
  \item{
  Run \verb|quadraticSieve(15,30,7,221)| and \verb|quadraticSieve(15,30,11,221)|.  Does this match [HPS 3.7.2]?
  }
  \item{
  Making the sieve was all the hard work!  What remains is pushing around data and doing linear algebra, and we're gonna let Sage do the linear algebra for us.  Write a function called \verb|sieveFactor(a,b,B,N)| which will try to factor $N=pq$ using the quadratic sieve from part 1.  It should loosely run as follows.
  \begin{enumerate}[(I)]
    \item{
    First run \verb|quadraticSieve(a,b,B,N)|.  From this you can extract the the $a_i$ between $a$ and $b$ such that $c_i = a_i^2-N$ is $B$-smooth, as well as the prime factorizations of the $c_i$.  In particular, you can extrac the $e_{ij}$ such that $c_i = p_1^{e_{i1}}p_2^{e_{i2}}\cdots p_t^{e_{it}}$ where the $p_i$ are precisely the primes $<B$.  Make a matrix (or nested array) \verb|E[i][j]=|$e_{ij}$
    }
    \item{
    Turn $E$ into a matrix $M$ over $\bF_2$ using the Sage command \verb|M = matrix(GF(2),E)|.  Then compute a basis for the nullspace of this matrix using \verb|basis = M.kernel().basis()|.  This does the row reduction you know and love from linear algebra!  \textit{Note: This turns out to be the slowest part of this algorithm!  There are better ways to solve sparse matrices of these form, but this is not really a class in computational linear algebra.}
    }
    \item{
    Each element of the basis gives you a subset of the $c_i$ whose product is a perfect square!  Let $B$ be the square root of this product, and let $A$ be the product of the corresponding $a_i$.  Now $\gcd(N,B-A)$ might just be your factor!  Try this for every element of your basis.
    }
  \end{enumerate}
  }
  \item{
  Let's test this out!
  \begin{enumerate}
    \item{
    Run \verb|sieveFactor(15,30,7,221)|.  Did it work?
    }
    \item{
    Recall that $L(X) = e^{\sqrt{\ln(X)\ln\ln(X)}}$.  If $a = \lfloor\sqrt N\rfloor + 1$, and $B = L(N)^{1/\sqrt{2}}$, then we saw in class that \verb|sieveFactor(a,a+L(N),B,N)| should work!  Try that out to factor the following numbers:
    \begin{enumerate}
      \item{8249}
      \item{7799773}
      \item{9488773076569}
      \item{1182692471909987}
    \end{enumerate}
    Unfortunately I couldn't really get it to factor anything bigger than this, but I think there's a lot of optimization one can do both in how you store the data and in how you do the linear algebra.
    }
  \end{enumerate}
  }
\end{enumerate}
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{4}
  \item{
  In problem 1 we computed square roots using Sage's built in functionality.  But if $p\equiv 3\mod 4$, there is actually an easy algorithm!  So fix $p\equiv 3\mod 4$ and let $a\in\bF_p^*$ have a square root mod $p$.  Give a $\cO(\log p)$ algorithm to compute a square root of $a$ modulo $p$, and prove its correctness.  (\textit{Hint: You can do this in a single exponentiation!})
  }
  \item{
  Let $L(X) = e^{\sqrt{\ln x\ln\ln x}}$.  Prove that $L(X)$ is subexponential (in the number of bits of $X$) by proving:
  \begin{enumerate}
    \item{
    $L(X) = \cO(X^\beta)$ for every $\beta>0$.
    }
    \item{
    $L(X) = \Omega((\ln X)^\alpha)$ for every $\alpha>0$.
    }
  \end{enumerate}
  }
  \item{
  Optimizing the various parts of our sieve factorization algorithm one can show that we can factor $N$ in about $\cO(L(N))$, which is subexponential!  Let's see how good this is.  For simplicity, suppose it takes about $L(N)$ computations to factor $N$, and we have a computer than can run a billion computations in a second.  How long would it take to factor $N$ of the following orders.  (Put your answer in seconds, days, years...whatever is appropriate.  Also if you do your computations on cocalc turn that part in too so the grader can see).
  \begin{enumerate}
    \item{$N\approx 2^{100}$.}
    \item{$N\approx 2^{250}$.}
    \item{$N\approx 2^{500}$.}
    \item{$N\approx 2^{1000}$.}
  \end{enumerate}
  }
\end{enumerate}
Recall the function $\Psi(X,B) =\#\{n\le X:n\text{ is }B\text{-smooth}\}.$  In class we stated the following claim about the growth of $\Psi$ in certain cases
\begin{theorem}[{[HPS] Theorem 3.43}]\label{TechnicalBit}
  Suppose there exists some $0<\varepsilon<1/2$ such that:
  \[(\ln X)^{\varepsilon} < \ln B < (\ln X)^{1-\varepsilon}.\]
  Let $u$ be the ratio $\ln X/\ln B$.  Then the number of $B$-smooth numbers less than $X$ satisfies:
  \[\Psi(X,B)\approx X u^{-u}.\]
\end{theorem}
(Note, here $\approx$ can be taken to mean that their difference is a function whose limit as $X$ goes to infinity is $0$, although in the book they have something slightly more precise).  This had the following Corollary, which is more useful for our analyis.
\begin{corollary}[{[HPS] Corollary 3.45}]\label{technicalCorollary}
  Let $0<c<1$.  Then:
  \[\Psi(X,L(X)^c))\approx X\cdot L(X)^{(-1/2c)}.\]
\end{corollary}
\begin{enumerate}
  \setcounter{enumi}{7}
  \item{
  Prove Corollary \ref{technicalCorollary} using Theorem \ref{TechnicalBit}.  In particular, prove the following two steps.
  \begin{enumerate}
    \item{
      Show that there exists some $0<\varepsilon<1/2$ with
      \[(\ln X)^\varepsilon < \ln (L(X)^c) < (\ln X)^{1-\varepsilon}.\]
    }
    \item{
    Let $u = \ln X/\ln(L(X)^c)$.  Show that:
    \[u^{-u}\approx L(X)^{-1/2c}.\]
    Then leverage that $\approx$ is transitive to deduce the corollary.\\ (\textit{Hint}: Write $u^{-u} = L(X)^{\frac{-1}{2c}(1+f(X))}$ for some function $f(X)$ such that $\lim_{X\to\infty} f(X) = 0$.  In fact, this is the definition of $\approx$ given in the book!).
    }
  \end{enumerate}
  }
\end{enumerate}
\end{document}
