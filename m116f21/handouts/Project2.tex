\documentclass[11pt]{article}
\usepackage[top = 1in, bottom = 1in, left =1in, right = 1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabu}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{seqsplit}
\usepackage{ulem}
\usepackage{tabularx}
\AtBeginEnvironment{proof}{\color{blue}}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem*{facts}{Fact}
\newtheorem*{remark}{Remark}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fancyhdr}\pagestyle{fancy}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tors}{\mathrm{tors}}
\newcommand{\ab}{\mathrm{ab}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\Inn}{\operatorname{Inn}}
\newcommand{\im}{\operatorname{im}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\ch}{\operatorname{char}}

%Math blackboard:
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bF}{\mathbb{F}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bQ}{\mathbb{Q}}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bS}{\mathbb{S}}
\newcommand{\bZ}{\mathbb{Z}}

%Math caligraphy
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}

%Greek blackboard font:
\newcommand{\bmu}{\mbox{$\raisebox{-0.59ex}
  {$l$}\hspace{-0.18em}\mu\hspace{-0.88em}\raisebox{-0.98ex}{\scalebox{2}
  {$\color{white}.$}}\hspace{-0.416em}\raisebox{+0.88ex}
  {$\color{white}.$}\hspace{0.46em}$}{}}

\lhead{University of California, Berkeley}
\rhead{Math 116, Fall 2021}

\begin{document}
\begin{center}
\Large {Takehome Project 2}\\
\small {Due Thursday, December 9}
\end{center}
In this assignment you will implement from the ground up a variant of Elliptic Curve Elgamal (callled Menezes-Vansone Elgamal or MV-Elgamal for short).  This includes implementing all the basics for elliptic curve arithmetic, including addition and `fast powering.'  You will also prove a few things about the algorithms you write.  As in the first project:
\begin{itemize}
  \item{Your work must be your own.  For this assignment do not work in groups or share code.}
  \item{It is open book: you may use the textbook, your class notes, my class notes and lecture videos, past homework assignments and their solutions, as well as the Sage and Python documentation.  Everything else is off limits.  I can also be a resource so don't hesitate to reach out!}
  \item{Part of the assignment is involves me sending a message to you and you replying.  Therefore you must share an Elliptic Curve Elgamal public key with me (on Discord or via email if you prefer), \textbf{by Tuesday December 7!}}
\end{itemize}
If you have questions, please reach out to me ASAP.  Ok, let's get started.  Have fun!
\section*{Implementation Part}
\begin{enumerate}
  \setcounter{enumi}{-1}
  \item{
  First gather your belongings.  You will need the extended euclidean algorithm, your implementations of the ASCII encoding schemes: \verb|textToInt| and \verb|intToText|, \verb|getBinary| from Homework 3, as well as \verb|findPrime| and all its dependencies from the first project.  You will also need your implementation of elliptic curves and elliptic curve arithmetic$-$\verb|isElliptic|, \verb|onCurve|, and \verb|addPoints|$-$from HW 10.
  }
  \item{
  Given $P,Q\in E(\bF_p)$ such that $Q = nP$, the Elliptic Curve Discrete Log Problem (ECDLP) is the problem of finding $n$.  The security of the ECDLP relies on the fact that computing adding $P$ to itself $n$ times is slow for large $n$.  But in order to harness this, we need to be able to compute $nP$ more quickly.  For the DLP over $\bF_p^*$, we used the \textit{fast powering algorithm}.  We will implement an analog of this here.
  \begin{enumerate}
    \item{
    Write an algorithm called \verb|doubleAndAdd(P,n,E,p)| which takes as input an elliptic curve $E$, a prime $p$, a positive integer $n$, and a point $P\in E(\bF_p)$, returning $nP\in E(\bF_p)$ using the double and algorithm from class:
    \begin{enumerate}[(1)]
      \item{Compute the binary expansion $[n_0,n_1,\cdots,n_r]$ of $n$.}
      \item{Compute $Q_i = 2^iP\in E(\bF_p)$ for $0\le i\le r$ by successive doubling.  (Notice that $Q_{i+1} = 2Q_i$)}
      \item{Compute $nP = n_0Q_0 + n_1Q_1 + \cdots + n_rQ_r\in E(\bF_p)$ in at most $r$ additions.}
    \end{enumerate}
    }
    \item{
    Like in HW2, for large values of $n$ \verb|doubleAndAdd| requires a remembering large amounts of data (including $\log_2(n)$ different multiples of $P$), which is not ideal.  Adapt HW 2 Problem 3(b) (\verb|fastPowerSmall|) to the elliptic curve case.  That is, write an aglorithm \verb|doubleAndAddSmall(P,n,E,p)| with the same inputs, but returning $nP$ with $\cO(1)$ storage space.  (In step (3) of HW3 3(b) you compute a floor, do this with the integer division operator: \verb|//|).
    }
    \item{Now let's test them out!
    \begin{enumerate}
      \item{
      Let $E$ be $y^2 = x^3 + 14x + 19$ over the prime $p = 3623$.  Let $P = (6,730)$.  Compute $947P$ with both algorithms above.  (This example is worked out in detail in [HPS] Example 6.16 and Table 6.4, so this would be a good example to troubleshoot with).
      }
      \item{
      Let $E$ be $y^2 = x^3 + 143x + 367$ over the prime $p=613$.  Let $P = (195,9)$.  Use both algorithms to compute $23P$.
      }
    \end{enumerate}
    }
  \end{enumerate}
  }
  \item{
  Many applications of elliptic curves (Including MV-Elgamal below) require as input an elliptic curve $E$ together with a (nonzero) point $P\in E(\bF_p)$.  One way to do this would be to start with an elliptic curve $y^2 = x^3 + Ax + B$, choose a random value for $x$, compute the right side of the equation, and then compute a square root to find $y$.  That being said, so far we only have an algorithm for square roots if $p\equiv 3\mod 4$, and we don't have space within this assignment to describe the general algorithm.  Instead, one can start with a point in $\bF_p^2$ and a random value of $A$ to derive $B$.  (This method will also come in handy for Lenstra's Elliptic Curve factorization algorithm where we need a point in $E(\bZ/N\bZ)$ where $N$ is not necessarily prime, and square roots become more elusive).
  \begin{enumerate}
    \item{
    Write an algorithm \verb|generateEllipticCurveAndPoint(p)| which takes as input a prime $p$ and outputs an elliptic curve \verb|E = [A,B]| and a nonzero point \verb|P = [x,y]| on the elliptic curve.  It should begin by randomly selecting a point $P\in\bF_p^2$, and $A\in\bF_p$, and should then derive $B$ from that data using the equation $y^2\equiv x^3+Ax+B\mod p$.  Make sure to check that you actually get an elliptic curve.
    }
    \item{
    Generate a curve and point over the following finite fields, and confirm that the point actually lies on the elliptic curve.
    \begin{enumerate}
      \item{$\bF_{13}$.}
      \item{$\bF_{1999}$.}
    \end{enumerate}
    }
  \end{enumerate}
  }
  \item{
  Now that everything is set up, we will implement the following variant of Elliptic Curve Elgamal, called Menezes-Vanstone Elgamal (MV-Elgamal).  We summarize the process in Table \ref{MVElgamal} on the next page (this is also summarized in Table 6.13 of [HPS]).
  \begin{table}\label{MVElgamal}
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|c|}{\textbf{Public Parameter Creation}}\\
      \hline
      \multicolumn{2}{|c|}{A large prime $p$, an elliptic curve $E$ over $\bF_p$, and a point $P\in E(\bF_p)$}\\
      \multicolumn{2}{|c|}{of large order is selected and published.}\\
      \hline
      \multicolumn{1}{|c|}{\textbf{Alice}} & \multicolumn{1}{|c|}{\textbf{Bob}}\\
      \hline
      \multicolumn{2}{|c|}{\textbf{Public Key Generation}}\\
      \hline
      Choose secret multiplyer $n_A$ & \\
      Compute $Q_A = n_AP$ & \\
      If $Q_A=\cO$ or $(x_A,0)$, choose a new $n_A$. & \\
      Publish the public key $Q_A$. & \\
      \hline
      \multicolumn{2}{|c|}{\textbf{Message Encryption}}\\
      \hline
      &Choose 2 plaintexts, $m_1,m_2\in\bF_p^*$.\\
      &Choose random number $k$.\\
      &Compute $R = kP,S=kQ_A\in E(\bF_p)$.\\
      &If either $R,S=\cO$, choose new $k$.\\
      &Write $S = (x_S,y_S)$.\\
      &If $x_S=0$ or $y_S=0$, choose a new $k$.\\
      &Compute $c_1 = x_Sm_1\mod p.$\\
      &Compute $c_2 = y_Sm_2\mod p.$\\
      &Send ciphertext $(R,c_1,c_2)$ to Alice.\\
      \hline
      \multicolumn{2}{|c|}{\textbf{Message Decryption}}\\
      \hline
      Compute $T = n_AR$ & \\
      Write $T = (x_T,y_T)$ & \\
      Compute $m_1' = x_T^{-1}c_1\mod p$ & \\
      Compute $m_2' = y_T^{-1}c_2\mod p$ & \\
      \textbf{$(m_1',m_2')=(m_1,m_2)$ is the message!} &\\
      \hline
    \end{tabular}
    \end{center}
    \caption{MV-Elgamal Encryption Scheme.}
  \end{table}
  Let's implement the various peices of this.
  \begin{enumerate}
    \item{
    Write a function \verb|MVParameterCreation(b)| which generates an elliptic curve $E$ and a nonzero point $P\in E(\bF_p)$ over a prime $p$ of $b$ bits, returning $E,P$, and $p$ in an array \verb|pubParams = [E,P,p]|.  (Use problem 2 and \verb|findPrime|.  Make sure that $P$ has order $>2$.).
    }
    \item{
    Write a function \verb|MVKeyCreation(pubParams)| which takes as input public parameters as above (an array consisting of a prime $p$, an elliptic curve $E$ over $\bF_p$, and a point $p\in E(\bF_p)$), and returns a pair \verb|[privateKey,publicKey]| consisting an an MV-Elgamal private key (which is an integer) and an MV-Elgamal public key (which is a point on $E(\bF_p)$).
    }
    \item{
    Write a function \verb|MVEncrypt(pubParams,m1,m2,publicKey)| which takes as inputs the public parameters, 2 plaintexts $m_1$ and $m_2$ (as elements of $\bF_p^*$), and Alice's MV-Elgamal public key (which is a point on $E(\bF_p)$).  It should output ciphertext \verb|cipherText = [R,c1,c2]| where $R\in E(\bF_p)$ and $c_1,c_2\in\bF_p^*$.
    }
    \item{
    Write a function \verb|MVDecrypt(pubParams,cipherText,privateKey)| which should take as input the public parameters, MV-Elgamal ciphertext \verb|[R,c1,c2]|, as well as Alice's private key (which is an integer).  It should return a pair of plaintexts \verb|[m1,m2]| which are elements of $\bF_p^*$.
    }
  \end{enumerate}
  }
  \item{
  Now let's use this to communicate!
  \begin{enumerate}
    \item{
    Generate a MV-Elgamal parameters and a key from a 32 bit prime.  Use it to encrypt and then decrypt $m_1 = 314159$ and $m_2 = 8675309$. Did it return the correct message?
    }
    \item{
    Let's use MV-Elgamal to communicate over a public channel.  Generate public parameters and an MV-Elgamal key from a 512 bit prime.  Post your public key on the Discord channel \verb|MV_Keys| \textbf{by Tuesday 12/7!} \textit{Save your private key!} Expect a message from me.
    }
    \item{
    I have generated the following MV-Elgamal parameters and public key from a 512 bit prime.  You will need this information to reply to my message.  My prime number is:

    $p = \\
    \seqsplit{%
    9238339210085821384370848649309951044287596836122824433369382270690704911115508332176060210977135155985773831184797326834780367925020889055994468078443941}
    $

    My elliptic curve is $E$ given by $y^2 = x^3 + Ax + B$, where:

    $A = \\
    \seqsplit{%
    3360587138488634548624334364567141352975246406473921428822627335581023930916403411066084961421298477347509247243673102565104835387508751726704037996443665}
    $
    $B = \\
    \seqsplit{%
    5274465680073198653436426409656856305708121812476359175465689738613250706291577435278096171212292781654086205248915051174084842023901074497831143355053310}
    $

    On this is base point $P = (x_P,y_P)$ where:

    $x_P = \\
    \seqsplit{%
    3894821325900829226661514573549835729125872222521286760219607535155140475566380261638014526024207181589942225595395557392022644429888469190609469251687317}
    $

    $y_P = \\
    \seqsplit{%
    2010326367004622284770020132754733324406289004622236940328670944464861121464189430879199099400468690110164705702449330074512245604434419522655885266701508}
    $
    }

    My public key is $Q = (x_Q,y_Q)$ where:


    $x_Q = \\
    \seqsplit{%
    8285333921858358272793493519906772530190584319638856643657772389736282152676235947510470165952693773814539643126521222828014548593322716383090625534896280}
    $

    $y_Q = \\
    \seqsplit{%
    5316530598908648856889223536521012873764423743873046963025605055921122703132845908355104500445027783863737649595841877172902771660618673858270962273557420}
    $
  \end{enumerate}
  }
\end{enumerate}
\section*{Written Part}
\begin{enumerate}
  \setcounter{enumi}{4}
  \item{Let's begin the written portion of this assignment by studying the correctness of the MV-Elgamal.
  \begin{enumerate}
    \item{
    Let $E$ be an elliptic curve modulo a prime $p$ and $P\in E(\bF_p)$ be a point not equal to $\cO$.  Prove that the order of $P$ is 2 if and only if it's $y$ coordinate is equal to 0.}
    \item{
    Use part (a) to explain why in the key creation phase of MV-Elgamal it was insisted that $Q_A$ must have a nonzero $y$ coordinate.
    }
    \item{
    Prove the correctness of MV-Elgamal.  (Be sure to explain why $x_S,y_S$ must be nonzero).
    }
    \item{
    The original Elgamal and the Elliptic Curve Elgamal essentially wrap together a Diffie-Hellman key exchange and a symmetric cipher into one procedure.  Explain why this is also the central philosophy of MV-Elgamal.  What plays the roll of the shared secret?  What about the symmetric key?
    }
  \end{enumerate}
  }
  \item{Let's now discuss the efficiency.
  \begin{enumerate}
    \item{Compute the time complexity of the following algorithms (in terms of the number of bits of your prime), proving your answer is correct.  You may assume the basic operations $+,-,\times,\div$ and choosing a random number are all $\cO(1)$. 
    \begin{enumerate}
    \item{\verb|doubleAndAddSmall|}
    \item{\verb|generateEllipticCurveAndPoint|}
    \item{\verb|MVParameterCreation| (Recall you computed the time complexity of \verb|findPrime| in Project 1}
    \item{\verb|MVKeyCreation|}
    \item{\verb|MVEncrypt|}
    \item{\verb|MVDecrypt|}
    \end{enumerate}
    }
    \item{
    What is the message expansion of MV-Elgamal?
    }
    \item{
    Suppose Alice has an algorithm to efficiently compute square roots modulo $p$ (such things certainly exist).  Explain a way that Bob could compress the ciphertext by sending 1 bit in place of the $y$-coordinate of $R$, and prove that your method works.  What would the new message expansion be?
    }
  \end{enumerate}
  }
  \item{
  Let's conclude with some potential attacks on MV-Elgamal.
  \begin{enumerate}
    \item{
    Show that if Eve can solve the Elliptic Curve Discrete Log Problem she can use it to crack MV-Elgamal.
    }
    \item{
    Show that if Eve can solve the Elliptic Curve Diffie Hellman Problem, she can use it to crack MV-Elgamal}
    \item{
    Eve knows the elliptic curve $E$, and intercepted the two peices of ciphertext $c_1,c_2$.  Explain how Eve could use this information to relate $m_1$ and $m_2$ in a polynomial equation (modulo $p$).  In particular, if Eve knows one of the peices of plaintext, she can use that to recover the other peice by solving an equation modulo $p$.  (The moral here is, both peices of plain text must be unique and private with each message.  For example: Bob should never leave one blank just because he doesn't need the space.)
    }
  \end{enumerate}
  }
\end{enumerate}
\end{document}
